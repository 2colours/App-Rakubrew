#!/usr/bin/env perl
# I AM RAKUDOBREW. ALSO POSSIBLY SPARTACUS. OUTLOOK CLOUDY, ASK AGAIN LATER.
use strict;
use warnings;
use 5.010;
use FindBin qw($RealBin $RealScript);
use lib "$RealBin/../lib";
use File::Path qw(remove_tree);
use File::Spec::Functions qw(catfile catdir splitpath updir);

use Rakudobrew::Build;
use Rakudobrew::VersionHandling;
use Rakudobrew::Tools;
use Rakudobrew::Variables;

# Detect incompatible version upgrade and notify user of the breakage.
unless (-d $shim_dir) {
    say STDERR "You seem to have upgraded rakudobrew to a newer version not compatible with";
    say STDERR "your current directory layout. Please remove rakudobrew completely by";
    say STDERR "removing $prefix and installing again.";
    exit 1;
}

unless (-d $git_reference) {
    mkdir $git_reference;
}

{ # Check whether we are called as a shim and forward if yes.
    my (undef, undef, $prog_name) = splitpath($0);

    # TODO: Mac is also case insensitive. Is this way to compensate for insensitivity safe?
    if ($prog_name ne $brew_name &&
    ($^O !~ /win32/i || $prog_name =~ /^\Q$brew_name\E\z/i)) {
        do_exec($prog_name, \@ARGV);
    }
}

my $arg = shift // 'help';

if ($arg eq 'version' || $arg eq 'current') {
    if (my $c = get_version()) {
        say "Currently running $c"
    } else {
        say STDERR "Not running anything at the moment. Use '$brew_name switch' to set a version";
        exit 1;
    }

} elsif ($arg eq 'versions' || $arg eq 'list') {
    my $cur = get_version() // '';
    map {
        my $version_line = '';
        $version_line .= $_ eq $cur ? '* ' : '  ';
        $version_line .= $_;
        $version_line .= ' -> ' . get_version_path($_) if is_registered_version($_);
        say $version_line;
    } get_versions();

} elsif ($arg eq 'global' || $arg eq 'switch') {
    if (!@ARGV) {
        my $version = get_global_version();
        if ($version) {
            say $version;
        }
        else {
            say "$brew_name: no global version configured";
        }
    }
    else {
        match_and_run($ARGV[0], sub {
            set_global_version(shift);
            validate_shell_hook_env($ARGV[0]);
        });
    }

} elsif ($arg eq 'shell') {
    if ($^O =~ /win32/i) {
        say <<EOT;
To (un)set a version locally in this running shell session use the following commands:
CMD:
SET $env_var=YOUR_VERSION
SET $env_var=                # Unset. No trailing whitespace!

PowerShell:
\$Env:$env_var="YOUR_VERSION"
Remove-Item Env:\\$env_var    # Unset.
EOT
    }
    else {
        if (!@ARGV) {
            my $shell_version = get_shell_version();
            if (defined $shell_version) {
                say "$shell_version";
            }
            else {
                say "$brew_name: no shell-specific version configured";
            }
        }
        else {
            validate_shell_hook_shell($ARGV[0]);
        }
    }

} elsif ($arg eq 'local') {
    validate_brew_mode();
    if (!@ARGV) {
        my $version = get_local_version();
        if ($version) {
            say $version;
        }
        else {
            say "$brew_name: no local version configured for this directory";
        }
    }
    else {
        match_and_run($ARGV[0], sub {
            set_local_version(shift);
            validate_shell_hook_env($ARGV[0]);
        });
    }

} elsif ($arg eq 'nuke' || $arg eq 'unregister') {
    my $version = shift;
    nuke($version);

} elsif ($arg eq 'rehash') {
    validate_brew_mode();
    rehash();

} elsif ($arg eq 'list-available') {
    my ($cur_backend, $cur_rakudo) = split '-', (get_version() // ''), 2;
    $cur_backend //= '';
    $cur_rakudo  //= '';
    say "Available Rakudo versions:";
    map { say $cur_rakudo eq $_ ? "* $_" : "  $_" } available_rakudos();
    say "";
    $cur_backend |= '';
    $cur_rakudo |= '';
    say "Available backends:";
    map { say $cur_backend eq $_ ? "* $_" : "  $_" } available_backends();

} elsif ($arg eq 'build') {
    my $impl = shift // 'moar';
    my $ver = shift
        if @ARGV && $ARGV[0] !~ /^--/;

    if (!defined $ver) {
        my @versions = available_rakudos();
        @versions = grep { /^\d\d\d\d\.\d\d/ } @versions;
        $ver = $versions[-1];
    }

    if ($impl eq "panda") {
        say "panda is discontinued; please use zef (rakudobrew build-zef) instead";
    } elsif ($impl eq "zef") {
        my $version = get_version();
        if (!$version) {
            say STDERR "$brew_name: No version set.";
            exit 1;
        }
        build_zef($version);
        # Might have new executables now -> rehash.
        rehash();
        say "Done, built zef for $version";
    } elsif (!exists $impls{$impl}) {
        my $warning = "Cannot build Rakudo with backend '$impl': this backend ";
        if ($impl eq "parrot") {
            $warning .= "is no longer supported.";
        } else {
            $warning .= "does not exist.";
        }
        say $warning;
        return;
    }
    else {
        my $configure_opts = '';
        if (@ARGV && $ARGV[0] =~ /^--configure-opts=/) {
            $configure_opts = shift;
            $configure_opts =~ s/^\-\-configure-opts=//;
            $configure_opts =~ s/^'//;
            $configure_opts =~ s/'$//;
        }

        if ($impl && $impl eq 'all') {
            for (available_backends()) {
                build_impl($_, $ver, $configure_opts);
            }
        } else {
            build_impl($impl, $ver, $configure_opts);
        }

        # Might have new executables now -> rehash.
        rehash();
        unless (get_version()) {
            set_global_version("$impl-$ver");
        }
        say "Done, $impl-$ver built";
    }

} elsif ($arg eq 'triple') {
    my ($rakudo_ver, $nqp_ver, $moar_ver) = (shift, shift, shift);
    my $name = build_triple($rakudo_ver, $nqp_ver, $moar_ver);

    # Might have new executables now -> rehash
    rehash();
    unless (get_version()) {
        set_global_version($name);
    }
    say "Done, $name built";

} elsif ($arg eq 'register') {
    my ($name, $path) = (shift, shift);
    if (!$name || !$path) {
        say STDERR "$brew_name: Need a version name and rakudo installation path";
        exit 1;
    }
    if (version_exists($name)) {
        say STDERR "$brew_name: Version $name already exists";
        exit 1;
    }

    sub invalid() {
        say STDERR "$brew_name: No valid rakudo installation found at '$path'";
        exit 1;
    }
    invalid() if !-d $path;
    $path = catdir($path, 'install') if !-f catfile($path, 'bin', 'perl6');
    invalid() if !-f catdir($path, 'bin', 'perl6');

    spurt(catfile($versions_dir, $name), $path);

} elsif ($arg eq 'build-zef') {
    my $version = get_version();
    if (!$version) {
        say STDERR "$brew_name: No version set.";
        exit 1;
    }
    build_zef($version);
    # Might have new executables now -> rehash
    rehash();
    say "Done, built zef for $version";

} elsif ($arg eq 'build-panda') {
    say "panda is discontinued; please use zef (rakudobrew build-zef) instead";

} elsif ($arg eq 'exec') {
    my $prog_name = shift;
    do_exec($prog_name, \@ARGV);

} elsif ($arg eq 'which') {
    if (!@ARGV) {
        say STDERR "Usage: $brew_name which <command>";
    }
    else {
        my $version = get_version();
        if (!$version) {
            say STDERR "$brew_name: No version set.";
            exit 1;
        }
        map {say $_} which($ARGV[0], $version);
    }

} elsif ($arg eq 'whence') {
    if (!@ARGV) {
        say STDERR "Usage: $brew_name whence [--path] <command>";
    }
    else {
        my $param = shift;
        my $pathmode = $param eq '--path';
        my $prog = $pathmode ? shift : $param;
        map {say $_} whence($prog, $pathmode);
    }

} elsif ($arg eq 'mode') {
    if (!@ARGV) {
        say get_brew_mode();
    }
    else {
        set_brew_mode($ARGV[0]);
        if (get_brew_mode() eq 'env') {
            validate_shell_hook_env($ARGV[0]);
        }
    }

} elsif ($arg eq 'self-upgrade') {
    self_upgrade();

} elsif ($arg eq 'init') {
    init(@ARGV);

} elsif ($arg eq 'test') {
    my $version = shift;
    if ($version && $version eq 'all') {
        for (get_versions()) {
            test($_);
        }
    } else {
        test($version);
    }

} elsif ($arg eq 'internal_shellmod') {
    print_shellmod_code(@ARGV);

} elsif ($arg eq 'internal_completions') {
    print generate_completions(@ARGV);

} elsif ($arg eq 'internal_completion_options') {
    print generate_completion_options(@ARGV);

} elsif ($arg eq 'internal_win_run') {
    my $prog_name = shift;
    my $path = which($prog_name, get_version());
    # Do some filetype detection:
    # - .exe/.bat/.cmd              -> return "filename"
    # - .nqp                        -> return "nqp filename"
    # - shebang line contains perl6 -> return "perl6 filename"
    # - shebang line contains perl  -> return "perl filename"
    # - nothing of the above        -> return "filename" # if we can't
    #                                  figure out what to do with this
    #                                  filename, let Windows have a try.
    # The first line is potentially the shebang. Thus the search for "perl" and/or perl6.
    my ($basename, undef, $suffix) = my_fileparse($prog_name);
    if($suffix =~ /^\Q\.(exe|bat|cmd)\E\z/i) {
        say $path;
    }
    elsif($suffix =~ /^\Q\.nqp\E\z/i) {
        say which('nqp', get_version()).' '.$path;
    }
    else {
        open(my $fh, '<', $path);
        my $first_line = <$fh>;
        close($fh);
        if($first_line =~ /#!.*perl6/) {
            say which('perl6', get_version()).' '.$path;
        }
        elsif($first_line =~ /#!.*perl/) {
            say 'perl '.$path;
        }
        else {
            say $path;
        }
    }

} else {
    my $backends = join '|', available_backends(), 'all';
    say <<"EOT";
Usage:
$brew_name version          # or $brew_name current
$brew_name versions         # or $brew_name list
$brew_name global [version] # or $brew_name switch [version]
$brew_name shell [--unset|version]
$brew_name local [version]
$brew_name nuke [version]   # or $brew_name unregister [version]
$brew_name rehash

$brew_name list-available
$brew_name build [$backends] [tag|branch|sha-1] [--configure-opts=]
$brew_name triple [rakudo-ver [nqp-ver [moar-ver]]]
$brew_name register <name> <path>
$brew_name build-zef

$brew_name exec <command> [command-args]
$brew_name which <command>
$brew_name whence [--path] <command>
$brew_name mode [env|shim]
$brew_name self-upgrade
$brew_name init

$brew_name test [version|all]
EOT
}

exit;

sub nuke {
    my $version = shift;
    match_and_run($version, sub {
        my $matched = shift;
        if (is_registered_version($matched)) {
            say "Unregistering $matched";
            unlink(catfile($versions_dir, $matched));
        }
        else {
            say "Nuking $matched";
            remove_tree(catdir($versions_dir, $matched));
        }
    });
    # Might have lost executables -> rehash
    rehash();
}

sub match_and_run {
    my ($version, $action) = @_;
    if (!$version) {
        say "Which version do you mean?";
        say "Available builds:";
        map {say} get_versions();
        return;
    }
    opendir(my $dh, $versions_dir);
    my @match = grep { /\Q$version/ } get_versions();
    my ($matched, $ambiguous) = @match;
    if ($ambiguous) {
        my ($exact) = grep { $_ eq $version } @match;
        if ($exact) {
            ($matched, $ambiguous) = $exact;
        }
    }
    if ($matched and not $ambiguous) {
        $action->($matched);
    } elsif (@match) {
        say "Sorry, I'm not sure if you mean:";
        say $_ for @match;
    } else {
        say "Sorry, I have no idea what '$version' is";
    }
}

sub available_backends {
    map {$_->{name}} sort {$a->{weight} <=> $b->{weight}} values %impls;
}

sub rehash {
    return if get_brew_mode() ne 'shim';

    my @paths = ();
    for my $version (get_versions()) {
        push @paths, get_bin_paths($version);
    }

    say "Updating shims";

    { # Remove the existing shims.
        opendir(my $dh, $shim_dir);
        while (my $entry = readdir $dh) {
            next if $entry =~ /^\./;
            unlink catfile($shim_dir, $entry);
        }
        closedir $dh;
    }

    my @bins = map { slurp_dir($_) } @paths;

    if ($^O =~ /win32/i) {
        # This wrapper is needed because:
        # - We want rakudobrew to work even when the .pl ending is not associated with the perl program and we do not want to put `perl` before every call to a shim.
        # - exec() in perl on Windows behaves differently from running the target program directly (output ends up on the console differently).
        # It retrieves the target executable (only consuming STDOUT of rakudobrew) and calls it with the given arguments. STDERR still ends up on the console. The return value is checked and if an error occurs that error values is returned.
        @bins = map { my ($basename, undef, undef) = my_fileparse($_); $basename } @bins;
        @bins = uniq(@bins);
        for (@bins) {
            spurt(catfile($shim_dir, $_.'.bat'), <<EOT);
\@ECHO OFF
SETLOCAL
SET brew_cmd=perl \%~dp0$brew_name internal_win_run \%~n0
FOR /F "delims=" \%\%i IN ('\%brew_cmd\%') DO SET command=\%\%i
IF NOT ERRORLEVEL 0 EXIT /B \%errorlevel\%
IF     ERRORLEVEL 1 EXIT /B \%errorlevel\%
\%command\% \%*
EOT
        }
    }
    else {
        for (@bins) {
            link $0, catfile($shim_dir, $_);
        }
    }
}

sub self_upgrade {
    chdir $prefix;
    run "$GIT pull";
}

sub test {
    my $version = shift || get_version();
    if (!$version) {
        say STDERR "$brew_name: No version set.";
        exit 1;
    }
    my @match = grep { /\Q$version/ } get_versions();
    my ($matched, $ambiguous) = @match;
    if ($ambiguous) {
        my ($exact) = grep { $_ eq $version } @match;
        if ($exact) {
            ($matched, $ambiguous) = $exact;
        }
    }
    if ($matched and not $ambiguous) {
        say "Spectesting $matched";
        chdir catdir($versions_dir, $matched);
        make('spectest');
    } elsif (@match) {
        say "Sorry, I'm not sure if you mean:";
        say $_ for @match;
    } else {
        say "Sorry, I have no idea what '$version' is";
        say "Have you run '$brew_name build $version' yet?";
    }
}

sub init {
    my $brew_exec = catfile($RealBin, $brew_name);
    if ($^O =~ /win32/i) {
        say <<EOT;
# CMD:
# To install $brew_name permanently type the following into your terminal:
#   SETX PATH "%PATH%;$RealBin"
# To make use of $brew_name in this session only use
#   SET PATH=%PATH%;$RealBin
#
# PowerShell:
# To install $brew_name permanently type the following into your terminal
# (only works with an administrative console window):
#   [Environment]::SetEnvironmentVariable("PATH", "\$Env:PATH;$RealBin", "User")
# To make use of $brew_name in this session only use
#   \$Env:PATH = "\$Env:PATH;$RealBin"
#
# Using the GUI:
# Start -> right click on "Computer" -> Properties -> (Advanced system settings)
# -> Advanced -> Environment Variables... ->  System variables
# -> select PATH -> Edit... -> append ";$RealBin"
EOT
    }
    else {
        if (@_ and $_[0] eq '-') {
            my $path = $ENV{PATH};
            $path = clean_path($path);
            $path = "$RealBin:$path";
            if (get_brew_mode() eq 'env') {
                $path = join(':', get_bin_paths(get_global_version()), $path);
            }

            my $shell_cmd = $ENV{SHELL};
            my $auto_complete = '';
            if ($shell_cmd =~ /bash/) {
                $auto_complete = <<"EOT";
_${brew_name}_completions() {
    COMPREPLY=(\$(command $brew_name internal_completions bash \$COMP_CWORD \$COMP_LINE))
    \$(command $brew_name internal_completion_options bash \$COMP_CWORD \$COMP_LINE)
}
complete -F _${brew_name}_completions $brew_name
EOT
            }

            say <<EOT;
export PATH=$path
$brew_name() {
  eval "`command $brew_name internal_shellmod "\$@"`"
  command $brew_name "\$@"
}
$auto_complete
EOT
        }
        else {
            say <<EOT;
# Load $brew_name automatically by adding
#   eval "\$($brew_exec init -)"
# to your local profile file.
# (often ~/.bash_profile or ~/.profile)
# This can be easily done using:

echo 'eval "\$($brew_exec init -)"' >> ~/.profile

EOT
        }
    }
}

sub print_shellmod_code {
    my @params = @_;
	my $command = shift(@params) // '';
	exit if $command ne 'global'
         && $command ne 'switch'
         && $command ne 'shell'
         && $command ne 'mode';

    if ($command eq 'shell' && @params) {
        if ($params[0] eq '--unset') {
            say get_shell_unsetter_code();
        }
        else {
            say get_shell_setter_code($params[0]);
        }
    }

    if (get_brew_mode() eq 'env') {
        my $version;
        if ($command eq 'global'
        or  $command eq 'switch'
        or  $command eq 'shell') {
            if (@ARGV) {
                if ($params[0] eq '--unset') {
                    $version = get_global_version();
                }
                else {
                    match_and_run($params[0], sub {
                        $version = $params[0];
                    });
                }
            }
        }

        exit if !defined $version;
        if ($command eq 'shell'
        or ($command eq 'global' || $command eq 'switch') && !defined get_shell_version()) {
            my $path = $ENV{PATH};
            $path = clean_path($path);
            $path = join(':', get_bin_paths($version), $path);
            say "export PATH=$path";
        }
    }
    elsif ($command eq 'mode') { # get_brew_mode() eq 'shim'
        my $path = $ENV{PATH};
        $path = clean_path($path);
        $path = $shim_dir . ':' . $path;
        say "export PATH=$path";
    }
}

sub generate_completions {
    my $shell = shift;
    my $index = shift;
    my @words = @_;

    if ($index == 1) {
        my @commands = qw(version current versions list global switch shell local nuke unregister rehash list-available build register build-zef exec which whence mode self-upgrade triple test);
        my $candidate = @words < 2 ? '' : $words[1];
        return join(' ', grep({ substr($_, 0, length($candidate)) eq $candidate } @commands));
    }
    elsif($index == 2 && ($words[1] eq 'global' || $words[1] eq 'switch' || $words[1] eq 'shell' || $words[1] eq 'local' || $words[1] eq 'nuke' || $words[1] eq 'test')) {
        my @versions = get_versions();
        push @versions, 'all'     if $words[1] eq 'test';
        push @versions, '--unset' if $words[1] eq 'shell';
        my $candidate = @words < 3 ? '' : $words[2];
        return join(' ', grep({ substr($_, 0, length($candidate)) eq $candidate } @versions));
    }
    elsif($index == 2 && $words[1] eq 'mode') {
        my @modes = qw(env shim);
        my $candidate = @words < 3 ? '' : $words[2];
        return join(' ', grep({ substr($_, 0, length($candidate)) eq $candidate } @modes));
    }
    elsif($index == 3 && $words[1] eq 'register') {
        my @completions;

        my $path = $words[3];
        my ($volume, $directories, $file) = splitpath($path);
        $path = catdir($volume, $directories, $file); # Normalize the path
        my $basepath = catdir($volume, $directories);
        opendir(my $dh, $basepath) or return '';
        while (my $entry = readdir $dh) {
            my $candidate = catdir($basepath, $entry);
            next if $entry =~ /^\./;
            next if substr($candidate, 0, length($path)) ne $path;
            next if !-d $candidate;
            $candidate .= '/' if length($candidate) > 0 && substr($candidate, -1) ne '/';
            push @completions, $candidate;
        }
        closedir $dh;
        return join(' ', @completions);
    }
}
sub generate_completion_options {
    my $shell = shift;
    my $index = shift;
    my @words = @_;

    if($index == 3 && $words[1] eq 'register') {
        return 'compopt -o nospace';
    }
    else {
        return '';
    }
}

sub get_shell_setter_code {
    my $version = shift;

    if ($^O =~ /win32/i) {
        #NYI on windows.
        die;
    }
    else {
        if (version_exists($version)) {
            return "export $env_var=\"$version\"";
        }
        else {
            return "echo \"$brew_name: version '$version' not installed.\";return 1";
        }
    }
}

sub get_shell_unsetter_code {
    if ($^O =~ /win32/i) {
        #NYI on Windows.
        die;
    }
    else {
        return "unset $env_var";
    }
}

sub clean_path {
    my $path = shift;
    my $old_path;
    do {
        $old_path = $path;
        $path =~ s/($versions_dir|$shim_dir)[^:]*:?//g;
        $path =~ s/:?($versions_dir|$shim_dir)[^:]*//g;
        $path =~ s/:($versions_dir|$shim_dir)[^:]*:/:/g;
    } until $path eq $old_path;
    return $path;
}

sub validate_shell_hook_env {
    if (get_brew_mode() eq 'env') {
        my $version = shift;
        return if !version_exists($version);
    
        my $path = join(':', get_bin_paths($version));
        if (index($ENV{PATH}, $path) == -1) {
            say STDERR "The shell hook required to use rakudobrew in 'env' mode seems not to be installed.";
            say STDERR "Run '$brew_name init' for installation instructions.";
        }
    }
}

sub validate_shell_hook_shell {
    my $version = shift;
    return if $version ne '--unset' && !version_exists($version);
    
    if ($version eq '--unset' && exists $ENV{$env_var}
    or $version ne '--unset' && ($ENV{$env_var} // '') ne $version) {
    say $ENV{$env_var} . ' ' . $version;
        say STDERR "The shell hook required to use rakudobrew in 'env' mode and use the 'shell' command seems not to be installed.";
        say STDERR "Run '$brew_name init' for installation instructions.";
    }
}

sub do_exec {
    my ($program, $args) = @_;

    my $target = which($program, get_version());
    
    # Run.
    exec { $target } ($target, @$args);
    die "Executing $target failed with: $!";
}

